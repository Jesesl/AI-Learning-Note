## 代码的规范性
面试官是根据应聘者写出的代码来决定是否录用他的。如果应聘者代码写得不够规范，影响面试官阅读代码的兴致，那么面试官就会默默地减去几分。

【影响因素】：

- 清晰的书写
- 清晰的布局
- 合理的命名

【清晰的书写】：绝大部分面试都是要求应聘者在白纸或者白板上书写。在面试过程中减慢写字的速度，尽量把每个字母写清楚还是很有必要的。不用担心没有时间去写代码，通常编程面试的代码量都不会超过  行，书写不用花多少时间，**关键是在写代码之前形成清晰的思路并能把思路用编程语言清楚地书写出来**。

【清晰的布局】：书写代码时需要注意循环以及判断，逻辑较复杂时，缩进的层次可能会比较多。如果布局不够清晰，缩进也不能体现代码的逻辑，那么面试官面对这样的代码将会头昏脑涨。

【合理的命名】：**强烈建议应聘者在写代码的时候，用完整的英文单词组合命名变量和函数**。如果一眼能看出变量、函数的用途，应聘者就能避免自己搞混淆而犯一些低级的错误。同时合理的命名也能让面试官一眼就能读懂代码的意图。

## 代码的完整性
在面试过程中，面试官会非常关注应聘者考虑问题是否周全。面试官通过检查代码是否完整来考查应聘者的思维是否全面。通常会检查：

- 应聘者的代码是否完成了基本功能；
- 输入边界值是否能得到正确的输出；
- 是否对各种不合规范的非法输入做出了合理的错误处理。

#### 从 3 个方面确保代码的完整性
应聘者在写代码之前，首先要把可能的输入都想清楚，从而避免在程序中出现各种各样的质量漏洞。也就是说，在编码之前要考虑单元测试。如果能够设计全面的单元测试用例并在代码中体现出来，那么写出的代码自然也就是完整正确的了。

【方面】：

- 功能测试
- 边界测试
- 负面测试

【功能测试】：首先要保证写出的代码能够完成面试官要求的基本功能。在考虑功能测试的时候，要尽量突破常规思维的限制，从题目中挖掘出更多的潜在信息和要求。

【边界测试】：很多时候我们的代码中都会有循环或者递归。如果我们的代码基于循环，那么结束循环的边界条件是否正确？如果基于递归，那么递归终止的边界值是否正确？这些都是边界测试时要考虑的用例。

【负面测试】：当输入不符合要求的时候需要作出合理的错误处理。

此外，在软件开发过程中，永远不变的是需求会一直改变。如果我们在面试的时候写出的代码能够把将来需求可能的变化都考虑进去，在需求发生变化的时候能够尽量减少代码改动的风险，那么我们就向面试官展示了自己对程序可扩展性和可维护性的理解。

#### 面试题 16：数值的整数次方
> 给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。

【测试用例】：

- 功能测试：base 和 exponent 分别取正数、0 和负数。
- 特殊输入处理：非整数次方。

【程序实现】：python ** 实现。
```python
def Power(base, exponent):
    if not isinstance(exponent, int):
        return None
    if base == 0:
        # 0 的 0 次幂没有意义
        if exponent == 0:
            return None
        return 0
    return base ** exponent


if __name__ == '__main__':
    base = 2.0
    base2 = 0.0
    base3 = -3.0
    test_exponent1 = 5
    test_exponent2 = 0
    test_exponent3 = -3
    test_exponent4 = 2.3
    print(Power(base, test_exponent1))
    print(Power(base2, test_exponent1))
    print(Power(base3, test_exponent1))
    print(Power(base, test_exponent2))
    print(Power(base, test_exponent3))
    print(Power(base3, test_exponent3))
    print(Power(base, test_exponent4))
```
【说明】：Python 的 \*\* 操作符可以实现乘方，并且支持浮点数幂，例如 `5 ** 2.3 == 40.51641491731905`。需要注意的是当 base = 0 且 exponent 为负数时，假设 exponent 为 -2。

![数学公式](https://latex.codecogs.com/gif.latex?base^{exponent}%20=%20\frac{1}{base^{-expoent}}%20=%20\frac{1}{0^2})

而 0 的任何次幂（除 0，0 的 0 次幂没有任何意义）都为 0，分母为 0 作除法会报错，因此需要进行特殊输入处理，在代码的前部加上：
```
if base == 0:
    return 0
```

【程序实现】：中规中矩的做法。
```python
def Power(base, exponent):
    if not isinstance(exponent, int):
        return None
    if base == 0:
        # 无意义
        if exponent == 0:
            return None
        return 0

    result = 1
    if exponent > 0:
        for i in range(exponent):
            result *= base
    else:
        for i in range(-exponent):
            result /= base
    return result
```
【说明】：其实只是在前一个示例的基础上实现了 Python 的 ** 操作。

【程序实现】：利用乘方公式来减少求整数次方的次数。
```python
def Power(base, exponent):
    # 特殊处理
    if not isinstance(exponent, int):
        return None
    if base == 0:
        # 无意义
        if exponent == 0:
            return None
        return 0
    # 判断 exponent 的正负
    is_neg = True if exponent < 0 else False
    # 如果是负数则取反
    if is_neg:
        exponent = -exponent
    if exponent & 0x1 == 0:
        result = loop_half_exponent(base, exponent)
    else:
        result = loop_half_exponent(base, exponent - 1) * base
    if is_neg:
        result = 1 / result
    return result


def loop_half_exponent(base, exponent):
    if exponent == 0:
        return 1
    if exponent == 1:
        return base
    result = base * base
    return loop_half_exponent(result, exponent >> 1)
```
【说明】：假设要输出的 exponent 为 32，如果我们知道它的 16 次方，那么只要在 16 次方的基础上再平方一次就可以了。而 16 次方是 8 次方的平方。这样以此类推，我们求 32 次方只需要做 5 次乘法：先求平方，在平方的基础上求 4 次方，在 4 次方的基础上求 8 次方，在 8 次方的基础上求 16 次方，最后在 16 次方的基础上求 32 次方。

![数学公式](https://latex.codecogs.com/gif.latex?base^{exponent}%20=%20\frac{1}a^n%20=%20\begin{cases}%20a^{n%20/%202}%20.%20a%20^{n%20/%202}%20\\%20a^{(n%20-%201)%20/%202}%20.%20a^{(n%20-%201)%20/%202}%20.%20a%20\end{cases})

【细节】：位运算的效率比乘除法及求余运算的效率要高很多。

- 右移运算符代替了除以 2。
- 位与运算符代替了求余运算符。

【本题考点】：

- 考查应聘者思维的全面性，不要忽视底数为 0 而指数为负数时的错误处理。
- 对效率要求高的面试官还会考查应聘者快速做乘方的能力。

#### 面试题 17：打印从 1 到最大的 n 位数
> 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

【测试用例】：

- 功能测试：n 为正整数
- 特殊输入测试：n = 0、n < 0、n 非整数

【程序实现】：
```python
def Print1ToMaxOfNDigits(n):
    if not isinstance(n, int) or n < 1:
        print('error!')
        return None

    max_num = 10 ** n
    for i in range(1, max_num):
        print(i)


if __name__ == '__main__':
    Print1ToMaxOfNDigits(3)
    Print1ToMaxOfNDigits(0)
    Print1ToMaxOfNDigits(2.4)
    Print1ToMaxOfNDigits(-5)
```
【说明】：这道题目看起来很简单，但这往往容易跳进面试官的陷阱。由于题目中没有规定 n 的范围，当输入的 n 很大时，求最大的 n 位数可能会导致整型溢出。也就是说，我们需要考虑大数问题。这是面试官在这道题里设置的一个大陷阱。

【方案】：最常用也是最容易的方法是用字符串或者数组来表达大数。

【程序实现】：用列表表达大数。
```python
def Print1ToMaxOfNDigits(n):
    # 特殊输入处理
    if not isinstance(n, int) or n < 1:
        print('error!')
        return None
        
    # 创建长度为 n 的列表
    number_list = [0] * n
    while number_add(number_list):
        print_number(number_list)


def number_add(number_list):
    bit = -1
    n = len(number_list)
    while True:
        if abs(bit) > n:
            return False
        number_bit = number_list[bit]
        number_bit += 1
        # print('number_bit:', number_bit)
        if number_bit == 10:
            number_list[bit] = 0
            bit -= 1
        else:
            number_list[bit] = number_bit
            break
    return True


def print_number(number_list):
    number_str = ""
    pos_start = 0
    for i in range(len(number_list)):
        if number_list[i] != 0:
            pos_start = i
            break
    for i in range(pos_start, len(number_list)):
        number_str += str(number_list[i])
    print(number_str)


if __name__ == '__main__':
    Print1ToMaxOfNDigits(3)
```
【说明】：

- 先根据 n 创建长度为 n 的列表，列表的每一个下标代表数字的每一位，例如 [1, 2, 3]，下标 0 代表百位，下标 1 代表十位。
- 实现列表模拟数字加法：对列表的最后一位（因为列表的最后一位代表个位）执行加一操作，如果满足进位则对列表的倒数第二位执行相同的操作，直到超过 n 的长度，此时返回 False，否则立即跳出循环，并返回 True。
- 实现列表拼成数字打印：从列表头部开始向右遍历，直到找到第一个非零的下标。然后将该下标后的各项添加到字符串变量中，最后打印该变量。

【程序实现】：数字排列，递归实现。
```python
def Print1ToMaxOfNDigits(n):
    if not isinstance(n, int) or n < 1:
        print('error!')
        return None
    loop_print('', n)


def loop_print(num, n):
    if n < 1:
        # 去除首位的零
        i = 0
        for i in range(len(num)):
            if num[i] != '0':
                break
        if num[i:] != '0':
            print(num[i:])
        return ""
    for i in range(10):
        loop_print(num + str(i), n - 1)
```
【说明】：

- n 位十进制数其实就是 n 个从 0 到 9 的全排列。也就是说，把数字的每一位都从 0 到 9 排列一遍，就得到了所有的十进制数。只是在打印的时候，排在前面的 0 不打印出来罢了。
- 全排列用递归很容易表达，数字的每一位都可能是 0~9 中的一个数，然后设置下一位。递归结束的条件是我们已经设置了数字的最后一位。

【本题考点】：

- 考查应聘者解决大数问题的能力。面试官出这道题目的时候，她期望应聘者能意识到这是一个大数问题，同事还期待应聘者能定义合适的数据表示方式来解决大数问题。
- 面试官还将关注应聘者打印数字时会不会打印出位于数字前面的 0。这里能体现出应聘者在设计开发软件时是不是会考虑用户的使用习惯。通常我们的软件设计和开发需要符合大部分用户的人机交互习惯。

#### 面试题 18：删除链表的节点
> 在 O(1) 时间内删除链表节点。给定单向链表的头指针和一个节点指针，定义一个函数在 O(1) 时间内删除该节点。

【链表结构】：
```python
class Node:

    def __init__(self, value):
        self.value = value
        self.next = None
```

【测试用例】：

- 功能测试：删除头节点、删除中间某节点、删除尾节点、只有一个节点。
- 特殊输入测试：空链表。

【程序实现】：
```python
def DeleteNode(head, node_to_be_deleted):
    if not head or not node_to_be_deleted:
        return None

    node_next = None
    if node_to_be_deleted.next:
        node_next = node_to_be_deleted.next
        node_to_be_deleted.value = node_next.value
        node_to_be_deleted.next = node_next.next
    else:
        if head == node_to_be_deleted:
            return None
        node = head
        while node:
            if node.next == node_to_be_deleted:
                node.next = None
                break
            node = node.next
    del node_next
    return head


def test_1():
    node_a = Node('a')
    node_b = Node('b')
    node_c = Node('c')
    node_a.next = node_b
    node_b.next = node_c
    return DeleteNode(node_a, node_b)


def test_2():
    node_a = Node('a')
    node_b = Node('b')
    node_c = Node('c')
    node_a.next = node_b
    node_b.next = node_c
    return DeleteNode(node_a, node_a)


def test_3():
    node_a = Node('a')
    node_b = Node('b')
    node_c = Node('c')
    node_a.next = node_b
    node_b.next = node_c
    return DeleteNode(node_a, node_c)


def test_4():
    node_a = Node('a')
    return DeleteNode(node_a, node_a)


if __name__ == '__main__':
    result_1 = test_1()
    result_2 = test_2()
    result_3 = test_3()
    result_4 = test_4()
    result_5 = DeleteNode(None, None)
```
【说明】：

- 在单向链表中删除一个节点，常规的做法无疑是从链表的头节点开始，顺序遍历查找要删除的节点，并在链表中删除该节点。由于需要顺序查找，时间复杂度自然是 O(n)。之所以需要从头开始查找，是因为我们需要得到将被删除节点的前一个节点。在单向链表中，节点没有指向前一个节点的指针，所以只好从链表的头节点开始顺序查找。
- 其实不一定需要得到被删除节点的前一个节点。我们只要把要删除节点的下一个节点的内容覆盖要删除节点的内容，再把下一个节点删除，就相当于把当前需要删除的节点给删除了。

【注意】：

- 若删除节点为链表的尾节点，即没有下一个节点，则必须从头节点开始循环遍历到该节点的前一个节点，并完成删除操作。
- 若链表只有一个节点，则删除该节点，并将头节点设置为 None。

【效率】：

- 时间效率：对于 n - 1 个非尾节点而言，可以在 O(1) 时间内完成删除操作。对于尾节点而言，由于仍然需要顺序查找，时间复杂度是 O(n)。因此，总的平均时间复杂度是 [(n - 1) x O(1) + O(n)] / n，结果还是 O(1)。

【其他】：值得注意的是，上述代码仍然不够完善，因为它基于一个假设：要删除的节点的确在链表中。我们需要 O(n) 的时间才能判断链表中是否包含某一节点。受到 O(1) 时间的限制，我们不得不确保节点在链表中的责任推给了函数 DeleteNode 的调用者。

【本题考点】：

- 考查应聘者对链表的编程能力。
- 考查应聘者的创新思维能力。
- 考查应聘者思维的全面性。

#### 面试题 18-2：删除链表中重复的节点
> 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1->2->3->3->4->4->5 处理后为 1->2->5。

【链表结构】：
```python
class ListNode:
    def __init__(self, x):
    self.val = x
    self.next = None
```

【测试用例】：

- 功能测试：存有重复节点（头部、中间、尾部）的链表，无重复节点的链表，单个节点的链表。
- 特殊输入测试：空链表、全为重复节点的链表。

【程序实现】：常规实现。
```python
def deleteDuplication(pHead):
    if not pHead:
        return None

    node_visited = {}
    node = pHead
    while node:
        if node.val in node_visited:
            node_visited[node.val] += 1
        else:
            node_visited[node.val] = 1
        node = node.next
    print('node_visited:', node_visited)

    head_node = ListNode(0)
    head_node.next = pHead
    node = pHead
    prev_node = head_node
    while node:
        if node_visited[node.val] > 1:
            prev_node.next = node.next
            node = node.next
        else:
            prev_node, node = node, node.next
    return head_node.next


if __name__ == '__main__':
    l1 = get_linklist([1, 2, 3, 3, 4, 4, 5])
    result1 = deleteDuplication(l1.root)
    l2 = get_linklist([1, 1, 2, 2, 3, 4, 5])
    result2 = deleteDuplication(l2.root)
    l3 = get_linklist([1, 2, 3, 4, 4, 5, 5])
    result3 = deleteDuplication(l3.root)
    l4 = get_linklist([1, 2, 3, 4, 5])
    result4 = deleteDuplication(l4.root)
    l5 = get_linklist([])
    result5 = deleteDuplication(l5.root)
    l6 = get_linklist([1])
    result6 = deleteDuplication(l6.root)
    l7 = get_linklist([1, 1, 2, 2])
    result7 = deleteDuplication(l7.root)
```
【说明】：首先遍历链表，获取每个节点的次数。再遍历链表的过程中将重复的节点依次删除。

【效率】：

- 时间效率：O(2n)
- 空间效率：需要借助额外的 node_visited 字典来存储重复节点的情况，最坏的情况是没有重复节点，因此需要 n 长度的字典，空间效率为 O(n)。

【程序实现】：对第一个程序实现的改进。
```python
    if not pHead:
        return None

    node_visited = {}
    node = pHead
    while node:
        if node.val in node_visited:
            node_visited[node.val] += 1
        else:
            node_visited[node.val] = 1
        node = node.next
    print('node_visited:', node_visited)

    node_prev = None
    node = pHead
    while node:
        if node_visited[node.val] > 1:
            node_next = node.next
            # 找到不重复的节点
            while node_next:
                if node_visited[node_next.val] == 1:
                    break
                node_next = node_next.next
            # 到达尾节点
            if not node_next:
                if not node_prev:
                    return None
                else:
                    node_prev.next = None
            else:
                node.val, node.next = node_next.val, node_next.next
        node_prev, node = node, node.next
    return pHead
```
【说明】：前面步骤相同，不同之处在于删除重复节点的过程。在遍历过程中，若发现当前节点为重复节点，则寻找下一个不重复的节点，将该节点作为当前节点的下一个节点。需要注意的是，若当前节点后面的节点全为重复节点，那么就需要将当前节点及后面的节点全部删除，因此需要借助 node\_prev，通过 node\_prev.next = None，来删除后续的节点。

【程序实现】：借助题目条件——排序。
```python

```

#### 面试题 19：正则表达式匹配
> 请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '*' 表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab*ac*a" 匹配，但是与 "aa.a" 和 "ab*a" 均不匹配。

【测试用例】：

- 特殊输入测试：输入字符串和模式字符串为 None，或空字符串。
- 功能测试：模式字符串包含普通字符、'.'、'*'；模式字符串和输入字符串匹配/不匹配。

```python
test_s1 = 'aaa'
test_p1 = 'a.a'
print(match(test_s1, test_p1))
test_s2 = ''
test_p2 = 'a.a'
print(match(test_s2, test_p2))
test_p3 = 'a*a'
print(match(test_s1, test_p3))
test_p4 = 'ab*ac*a'
print(match(test_s1, test_p4))
test_p5 = 'aa.a'
print(match(test_s1, test_p5))
test_s3 = ''
test_p6 = 'c*'
print(match(test_s3, test_p6))
test_p7 = '.*'
print(match(test_s3, test_p7))
print(match('a', test_p7))
```

【程序实现】：
```python
def match(s, pattern):
    # write code here
    if (len(s) == 0 and len(pattern) == 0):
        return True
    if (len(s) > 0 and len(pattern) == 0):
        return False
    if (len(pattern) > 1 and pattern[1] == '*'):
        if (len(s) > 0 and (s[0] == pattern[0] or pattern[0] == '.')):
            return (self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:]) or self.match(s[1:], pattern))
            else:
            return self.match(s, pattern[2:])
    if (len(s) > 0 and (pattern[0] == '.' or pattern[0] == s[0])):
        return self.match(s[1:], pattern[1:])
    return False
```
【说明】：具体内容可参考《剑指offer》P124~P125

【本题考点】：

- 考查应聘者对字符串的编程能力；
- 考查应聘者对正则表达式的理解；
- 考查应聘者思维的全面性。

#### 面试题 20：表示数值的字符串
> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 "+100", "5e2", "-123", "3.1416" 和 "-1E-16" 都表示数值。 但是 "12e", "1a3.14", "1.2.3", "+-5" 和 "12e+4.3" 都不是。

【测试用例】：

- 功能测试：+100、5e2、-123、3.1416、-1E-16、3.14e-2、12e、1a3.14、1.2.3、+-5、12e+4.3、e+4.3、12e+4、-012e+4、010
- 特殊输入测试：非字符串。

【程序实现】：
```python
def isNumeric(s):
    char_number = ('1', '2', '3', '4', '5', '6', '7', '8', '9', '0')
    char_index = 0
    has_e, has_dot, is_first = False, False, True
    for char in s:
        if char in char_number:
            if is_first and char == '0' and s[char_index + 1] != '.':
                return False
            is_first = False
            char_index += 1
        elif char == '.':
            # e 后接整数
            if has_e:
                return False
            # 出现两个小数点，则有错
            if has_dot:
                return False
            has_dot = True
            char_index += 1
        elif char == '+' or char == '-':
            if char_index == 0 or s[char_index - 1] == 'e' or s[char_index - 1] == 'E':
                char_index += 1
            else:
                return False
        elif char == 'e' or char == 'E':
            # 出现两次 e，则表明有错
            if has_e:
                return False
            # e 的前方必须要有数值
            if char_index - 1 > 0 and s[char_index - 1] not in char_number:
                return False
            # 否则表明当前存在 e
            has_e = True
            char_index += 1
        # 若以上情况都不存在，则表明有其他字符，返回 False
        else:
            return False
    if s[-1] == '+' or s[-1] == '-' or s[-1] == 'e' or s[-1] == 'E':
        return False
    return True


if __name__ == '__main__':
    test_s1 = '+100'
    print(isNumeric(test_s1))
    test_s2 = '5e2'
    print(isNumeric(test_s2))
    test_s3 = '-123'
    print(isNumeric(test_s3))
    test_s4 = '3.1416'
    print(isNumeric(test_s4))
    test_s5 = '-1E-16'
    print(isNumeric(test_s5))
    test_s6 = '12e'
    print(isNumeric(test_s6))
    test_s7 = '1a3.14'
    print(isNumeric(test_s7))
    test_s8 = '1.2.3'
    print(isNumeric(test_s8))
    test_s9 = '+-5'
    print(isNumeric(test_s9))
    test_s10 = '12e+4.3'
    print(isNumeric(test_s10))
    test_s11 = 'e+4.3'
    print(isNumeric(test_s11))
    test_s12 = '12e+4'
    print(isNumeric(test_s12))
    test_s13 = '-012e+4'
    print(isNumeric(test_s13))
    test_s14 = '010'
    print(isNumeric(test_s14))
    test_s15 = '0.123'
    print(isNumeric(test_s15))
```
【说明】：

- [0~9]：第一个数值不能为 '0'，仅有后面为小数点才行，即 0.123。
- '.'：小数点有且仅有一个，且小数点不能出现在 e 的后面。
- '+' or '-'：正负号只能出现在第一位或者在 e（E）的后面。
- 'e' or 'E'：有且仅有一个，且前后必须存在数值。

【程序实现】：正则表达式。
```python
def isNumeric(s):
    pattern = re.compile('[+-]?\d*(\.\d+)?([eE][+-]?\d+)?')
    return len(s) == pattern.match(s).end()
```
【说明】：分为三部分，整数、小数以及指数。

- 整数：[+-]?\d*。
- 小数：可选 (\.\d+)?，切记 . 需要转义，因为 . 是任意字符。
- 指数：可选 ([eE][+-]?\d+)?。
- 此外，在这种方式下，010 也视作正确。

【本题考点】：

- 考查应聘者对字符串的编程能力。
- 考查应聘者分析问题的能力。面试官希望应聘者能够从不同类型的数值中分析出规律。
- 考查应聘者思维的全面性。应聘者要全面考虑数值整数、小数、指数部分的特点。

#### 面试题 21：调整数组顺序使奇数位于偶数前面
> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

【测试用例】：

- 功能测试：符合要求的数组、完全不符合要求的数组、奇数长度的数组、偶数长度的数组。
- 特殊输入测试：空数组。

【程序实现】：遍历 + 额外空间。
```python
def reOrderArray(array):
    array_even = []
    odd_pos = 0

    for item in array:
        if item & 0x01 == 0:
            array_even.append(item)
        else:
            array[odd_pos] = item
            odd_pos += 1
    for item in array_even:
        array[odd_pos] = item
        odd_pos += 1


if __name__ == '__main__':
    # 特殊输入处理：空数组
    test_array_1 = []
    reOrderArray(test_array_1)
    print(test_array_1)

    # 功能测试：偶数长度
    test_array_2 = [1, 2, 4, 3, 6, 7]
    reOrderArray(test_array_2)
    print(test_array_2)

    # 功能测试：奇数长度
    test_array_2_2 = [1, 2, 4, 3, 6, 7, 8]
    reOrderArray(test_array_2_2)
    print(test_array_2_2)

    # 功能测试：已经符合要求
    test_array_3 = [1, 3, 5, 2, 4, 6]
    reOrderArray(test_array_3)
    print(test_array_3)

    # 功能测试：完全不符合要求
    test_array_4 = [2, 4, 6, 1, 3, 5]
    reOrderArray(test_array_4)
    print(test_array_4)
```
【效率】：

- 时间效率：由于需要遍历一次数组和新创建的列表，因此需要时间 O(n)。
- 空间效率：需要创建额外的列表，最坏的情况下是数组全为偶数，因此需要 O(n) 长度的空间。

【注意】：牛客网上的题目要求和书本有出入，新增了**奇数间、偶数间相对位置不变**的要求。不过对于后续的扩展要求是可以实现的。
- 负数在非负数的前方。

```python
if item / param < 0:
    array_even.append(item)


test_array = [-1, 3, -2, 6, -7, 8]
reOrderArray(test_array, -1)
print(test_array)
```
- 被 3 整除的数放在不能被 3 整除的数前面。

```python
if item % param != 0:
    array_even.append(item)
    
    
test_array = [3, 4, 5, 6, 8, 9]
reOrderArray(test_array, 3)
print(test_array)
```
实际上，奇数和偶数是上述代码的一个特例，即 param == 2。除此之外，修改 != 和 == 来调整前后顺序。

【建议】：如果面试官不断地问你一道题目在不同条件下该如何处理时，你要立即反应过来，面试官期待我们提供的不仅仅是解决一个问题的办法，而是解决一系列同类问题的通用办法。

【本题考点】：

- 考查应聘者的快速思维能力。
- 考查应聘者对扩展性的理解，要求应聘者写出的代码具有可重用性。

## 代码的鲁棒性
鲁棒是英文 Robust 的音译，有时也翻译成健壮性。所谓的鲁棒性是指程序能够判断输入是否合乎规范要求，并对不符合要求的输入予以合理的处理。

容错性是鲁棒性的一个重要体现。不鲁棒的软件在发生异常事件的时候，比如用户输入错误的用户名、试图打开的文件不存在或者网络不能连接，就会出现不可预见的诡异行为，或者干脆整个软件崩溃。

由于鲁棒性对软件开发非常重要，所以面试官在招聘的时候对应聘者写出的代码是否鲁棒也非常关注。**提高代码的鲁棒性的有效途径是进行防御性编程**。

【防御性编程】：预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。

在面试时，最简单也最实用的防御性编程就是在函数入口添加代码以验证用户输入是否符合要求。当然，并不是所有与鲁棒性相关的问题都只是检查输入的参数这么简单。看到问题时，需要思考题目中隐含着的条件。

#### 面试题 22：链表中倒数第 K 个节点
> 输入一个链表，输出该链表中倒数第k个结点。

【数据结构】：
```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```

【测试用例】：

- 功能测试：非空链表，正整数 k。
- 特殊输入测试：空链表，非正整数 k（负数、零或小数），k 大于链表长度。

【程序实现】：中规中矩做法。
```python
def FindKthToTail(head, k):
    if not head or k <= 0:
        return None

    stack = []
    node = head
    while node:
        stack.append(node)
        node = node.next
    if k > len(stack):
        return None
    return stack[-k]
```
【说明】：因为是单向链表，所以得从头节点开始向尾节点遍历一遍，将遍历的节点保存到堆栈中。接着利用堆栈的特性来实现获取倒数第 k 个节点。

【效率】：

- 时间效率：O(n)，最坏的情况是 k 刚好等于链表长度，因此需要两个 O(n) 时间（当实际上 Python 获取列表中元素的时间为 O(1)），近似于 O(n)。
- 空间效率：O(n)，需要开辟等同于链表长度的堆栈空间。

【程序实现】：巧妙的双指针做法。
```python
def FindKthToTail(head, k):
    if not head or k <= 0:
        return None

    iter_count = 0
    node = head
    node_k = None
    while node:
        node = node.next
        iter_count += 1
        if iter_count >= k:
            if not node_k:
                node_k = head
            else:
                node_k = node_k.next
    return node_k
```
【说明】：定义两个指针，第一个指针从链表的头指针开始遍历向前走 k - 1 步，第二个指针保持不动；从第 k 步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在 k - 1，当第一个指针达到链表的尾节点时，第二个指针正好指向倒数第 k 个节点。

虽然递归也能实现，不过得借助递归函数外的全局变量或对象属性来实现。

【本题考点】：

- 考查应聘者对链表的理解。
- 考查应聘者所写代码的鲁棒性。

#### 面试题 22-2：求链表的中间节点
> 求链表的中间节点。如果链表中的节点总数为奇数，则返回中间节点；如果节点总数是偶数，则返回中间两个节点的任意一个。

【测试用例】：

- 功能测试：节点总数为奇数的链表、节点总数为偶数的链表。
- 特殊输入测试：空链表。

【数据结构】：
```python
class ListNode:

    def __init__(self, x):
        self.val = x
        self.next = None
```

【程序实现】：中规中矩。
```python
def FindMiddleToTail(head):
    if not head:
        return None

    # 额外开辟一块内存空间，以堆栈的形式存储遍历节点
    stack = []
    node = head
    while node:
        stack.append(node)
        node = node.next
    return stack[int(len(stack) / 2)]
```
【说明】：遍历获取链表个节点，并存储到列表中，最后获取列表中间位置的节点。

【程序实现】：双指针。
```python
def FindMiddleToTail(head):
    if not head:
        return None

    node = head
    node_2 = head
    while node_2:
        if not node:
            break
        node = node.next
        if not node:
            break
        node = node.next
        node_2 = node_2.next
    return node_2
```
【说明】：当 node\_2 指针走一步时，node 指针走两步，因此当 node 指针走到尾节点时，此时 node\_2 指针指向中间节点。

【效率】：

- 时间效率：O(n/2)
- 空间效率：O(1)

当然，我们也可以让 node 作为外层循环的判定条件。
```python
def FindMiddleToTail(head):
    if not head:
        return None

    node = head
    node_2 = head
    iter_count = 1
    while node:
        if iter_count & 0x01 == 0:
            node_2 = node_2.next
        iter_count += 1
        node = node.next
    return node_2
```
【效率】：

- 时间效率：O(n)
- 空间效率：O(1)

实际上获取链表的中间节点等同于获取链表倒数 K 节点的一个特殊情况，即 k = 链表长度的一半。

#### 面试题 23：链表中环的入口节点
> 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。

【数据结构】：
```python
class ListNode:

    def __init__(self, x):
        self.val = x
        self.next = None
```

【测试用例】：

- 功能测试：含有环的链表，没有环的链表，单个节点的链表。
- 特殊输入测试：空链表。

【程序实现】：记录节点的方式。
```python
def EntryNodeOfLoop(pHead):
    if not pHead:
        return None
    node_list = []
    node = pHead
    while node:
        if node in node_list:
            return node
        node_list.append(node)
        node = node.next
    return None
```
【说明】：遍历链表的同时记录下每次遍历的节点信息，同时判断当前节点是否已经被记录。若已被记录则说明当前节点是环的入口。

【效率】：

- 时间效率：O(n)，至少遍历一遍链表。
- 空间效率：O(n)，需要与链表等长的列表。

【程序实现】：双指针法。
```python
def EntryNodeOfLoop(pHead):
    node_ptr_1, node_ptr_2 = pHead, pHead
    is_loop, length = False, 1
    # 判断是否成环
    while node_ptr_2:
        node_ptr_1 = node_ptr_1.next
        if not node_ptr_1:
            return None
        if node_ptr_1 == node_ptr_2:
            # 成环，则找出链表的长度
            is_loop = True
            node_ptr_2 = node_ptr_2.next
            while node_ptr_2 != node_ptr_1:
                length += 1
                node_ptr_2 = node_ptr_2.next
            break
        node_ptr_1 = node_ptr_1.next
        if not node_ptr_1:
            return None
        if node_ptr_1 == node_ptr_2:
            is_loop = True
            node_ptr_2 = node_ptr_2.next
            while node_ptr_2 != node_ptr_1:
                length += 1
                node_ptr_2 = node_ptr_2.next
            break
        node_ptr_2 = node_ptr_2.next
    # 不成环，则返回 None
    if not is_loop:
        return None

    node_ptr_1, node_ptr_2 = pHead, pHead
    # 先让其中一个指针移动 length 长度
    for i in list(range(length)):
        node_ptr_2 = node_ptr_2.next
    while node_ptr_1 != node_ptr_2:
        node_ptr_1 = node_ptr_1.next
        node_ptr_2 = node_ptr_2.next
    return node_ptr_2
```
【说明】：

- 如何确定一个链表找中包含环：定义两个指针，同时从链表的头节点出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表就包含环；如果走得快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不包含环。
- 如何找到环的入口：先定义两个指针指向链表的头节点，如果链表中的环有 n 个节点，则第一个指针先在链表上移动 n 步，然后两个指针以相同的速度向前移动。当第二个指针指向环的入口时，第一个指针已经围绕环走了一圈，又回到了入口节点。因此判断这两个指针相同，则指针指向的节点即为入口节点。
- 如何得到环中节点的数目：在判断是否环的过程中，若存在环则继续执行下述操作。从当前节点触发，一边继续向前移动一边计数，当再次回到该节点时，就可以得到环中节点数了。
- 上述代码还可以继续进行优化。

【本题考点】：

- 考查应聘者对链表的理解。
- 考查应聘者所写代码的鲁棒性。
- 考查应聘者分析问题的能力。

#### 面试题 24：反转链表
> 输入一个链表，反转链表后，输出新链表的表头。

【数据结构】：
```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```

【测试用例】：

- 功能测试：长度为 1 的链表，任意长度的链表。
- 特殊输入测试：空链表。

```python
if __name__ == '__main__':
    # 功能测试
    test_node1 = get_linklist([1, 2, 3, 4, 5])
    result1 = ReverseList(test_node1.root)

    # 功能测试：长度为 1 的链表
    test_node2 = get_linklist([1])
    result2 = ReverseList(test_node2.root)

    # 特殊输入测试
    result3 = ReverseList(None)
```

【程序实现】：借助堆栈实现。
```python
def ReverseList(pHead):
    node_list = [None]
    node = pHead
    while node:
        node_list.append(node)
        node = node.next
    node = node_list.pop()
    head = node
    while node:
        cur_node = node_list.pop()
        node.next = cur_node
        node = cur_node
    return head
```
【说明】：借助堆栈（列表）来存放所有链表节点，并利用堆栈的特性来反转链表。需要注意的是 node\_list 开始存有 None，其目的是让当前的尾节点（先前的头节点）的 next 指向 None。

【效率】：

- 时间效率：需要循环两次链表长度，因此需要 O(2n) 的时间。
- 空间效率：需要额外的堆栈，堆栈的长度等同于链表的长度，因此需要 O(n) 的内存空间。

【程序实现】：递归 + 全局变量。
```python
head = None


def ReverseList(pHead):
    if not pHead:
        return None
    tail = loop(pHead)
    tail.next = None
    return head

def loop(node):
    if node.next:
        node_next = loop(node.next)
        node_next.next = node
        return node
    global head
    head = node
    return node
```
【说明】：递归用于反转链表，但需要注意的是反转后的头节点需要用全局变量来存储，并且反转后的尾节点（先前的头节点）的下一个指针仍然是指向尾节点的前一个节点，因此需要在递归调用结束后，将返回的尾节点的下一个指针指向 None。

【效率】：

- 时间效率：链表长度的递归调用次数，因此时间效率为 O(n)。
- 空间效率：链表长度的递归调用深度，空间效率为 O(n)。

【程序实现】：巧妙的实现方式。
```python
def ReverseList(pHead):
    node = pHead
    node_prev = None
    while node:
        node_next = node.next
        node.next = node_prev
        node_prev, node = node, node_next
    return node_prev
```
【说明】：初始化时，将头节点作为当前节点，空节点作为上一个节点。在遍历链表时，首先获取下一个节点，然后将当前节点的 next 指向上一个节点，最后将当前节点赋值给上一个节点，下一个节点赋值给当前节点，以此来进行循环。

【核心思想】：遍历的过程中用新的变量保存当前节点的下一个节点信息，因此修改当前节点的 next 值时不会影响到循环。

【效率】：

- 时间效率：O(n)。
- 空间效率：O(1)。

【需要注意的问题】：

- 输入空链表或者整个链表只有一个节点时，程序立即崩溃。
- 反转后的链表出现断裂。
- 返回的反转之后的头节点不是原始链表的尾节点。

【本题考点】：

- 考查应聘者对链表、指针的编程能力。
- 特别注重考查应聘者思维的全面性及写出来的代码的鲁棒性。

#### 面试题 25：合并两个排序的列表
> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

【数据结构】：
```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```

【测试用例】：

- 功能测试：两个链表有多个节点，节点的值互不相同或者存在值相等的多个节点。
- 特殊输入测试：两个链表有一个或者两个都为空链表，两个链表中只有一个节点。

```python
def traversal(node):
    node_list = []
    if not node:
        print('None')
    while node:
        node_list.append(node.val)
        node = node.next
    print(str(node_list))


def test_1():
    """
    特殊输入测试：存在空链表
    """
    result1 = Merge(None, None)
    traversal(result1)
    result2 = Merge(None, get_linklist([1, 2, 3, 4, 5]).root)
    traversal(result2)
    result3 = Merge(get_linklist([1, 2, 3, 4, 5]).root, None)
    traversal(result3)
    result4 = Merge(get_linklist([1]).root, get_linklist([2]).root)
    traversal(result4)


def test_2():
    """
    功能测试：
    """
    result1 = Merge(get_linklist([1, 3, 5, 7, 9]).root, get_linklist([2, 4, 6, 8, 10]).root)
    traversal(result1)
    result2 = Merge(get_linklist([1]).root, get_linklist([2, 4, 6, 8, 10]).root)
    traversal(result2)
    result3 = Merge(get_linklist([1, 3, 5, 7, 9]).root, get_linklist([2]).root)
    traversal(result3)
    result4 = Merge(get_linklist([1, 3, 5, 7, 9]).root, get_linklist([2, 3, 4, 5]).root)
    traversal(result4)


if __name__ == '__main__':
    print('test1')
    test_1()
    print('------')
    print('test2')
    test_2()
    print('------')
```

【程序实现】：双指针做法。
```python
def Merge(pHead1, pHead2):
    ptr_1, ptr_2 = pHead1, pHead2
    if not pHead1:
        return pHead2
    elif not pHead2:
        return pHead1
    if ptr_1.val < ptr_2.val:
        head = ptr_1
        ptr_1 = ptr_1.next
    else:
        head = ptr_2
        ptr_2 = ptr_2.next
    node = head
    while True:
        if not ptr_1:
            node.next = ptr_2
            break
        if not ptr_2:
            node.next = ptr_1
            break

        if ptr_1.val < ptr_2.val:
            node.next = ptr_1
            ptr_1 = ptr_1.next
        else:
            node.next = ptr_2
            ptr_2 = ptr_2.next
        node = node.next
    return head
```
【说明】：先确定头节点，然后在循环体内比较两个链表当前位置的大小，若链表 1 的值小于链表 2 的值，则上一个节点的 next 指向链表 1 当前节点，并让链表 1 的指针指向下一个节点。按照该步骤依次循环，直到到达某个链表的尾节点，此时让另一个链表添加到当前节点的尾部即可。

【效率】：

- 时间效率：最糟糕的情况是两个链表的数据相互交叉，即 [1, 3, 5, 7]，[2, 4, 6, 8] 这种情况，因此遍历的时长为 O(2n)。
- 空间效率：O(1)。

【程序实现】：递归的方式。
```python
def Merge(pHead1, pHead2):
    if not pHead1:
        return pHead2
    if not pHead2:
        return pHead1

    if pHead1.val < pHead2.val:
        pHead1.next = Merge(pHead1.next, pHead2)
        return pHead1
    else:
        pHead2.next = Merge(pHead1, pHead2.next)
        return pHead2
```
【说明】：考虑过程可以参考《剑指offer》第 145-147 页的内容。不过其实也挺好理解的，先选出两个头节点中最小的节点作为当前节点，然后调用 Merge() 从余下的链表中再次取出下一个节点，依次执行直到其中一个链表为空，此时将另外一个链表作为尾部添加到合并链表的尾部即可。

【本题考点】：

- 考查应聘者分析问题的能力。
- 考查应聘者能不能写出鲁棒的代码。

#### 面试题 26：树的子结构
> 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

【数据结构】：
```python
class TreeNode:

    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

【测试用例】：

- 功能测试：树A 和树 B 都是普通的二叉树且符合要求，不符合要求，树 A 和树 B 只有左子树或右子树。
- 特殊输入测试：空树，只有根节点的树。

```python
node1 = TreeNode(8)
node2 = TreeNode(8)
node3 = TreeNode(7)
node4 = TreeNode(9)
node5 = TreeNode(2)
node6 = TreeNode(4)
node7 = TreeNode(7)
node1.left, node1.right = node2, node3
node2.left, node2.right = node4, node5
node5.left, node5.right = node6, node7

# 特殊输入测试：空树
result1 = HasSubtree(node1, None)

# 特殊输入测试：只有根节点
result2 = HasSubtree(node1, TreeNode(4))

# 功能测试：
sub_node1 = TreeNode(8)
sub_node2 = TreeNode(9)
sub_node3 = TreeNode(2)
sub_node1.left, sub_node1.right = sub_node2, sub_node3
result3 = HasSubtree(node1, sub_node1)

# 功能测试：
sub_node1 = TreeNode(8)
sub_node2 = TreeNode(9)
sub_node3 = TreeNode(2)
sub_node4 = TreeNode(7)
sub_node1.left, sub_node1.right = sub_node2, sub_node3
sub_node2.left = sub_node4
result4 = HasSubtree(node1, sub_node1)

# 功能测试：
node1 = TreeNode(8)
node2 = TreeNode(8)
node3 = TreeNode(9)
node4 = TreeNode(2)
node5 = TreeNode(5)
node1.right, node2.right = node2, node3
node3.right, node4.right = node4, node5
sub_node1 = TreeNode(8)
sub_node2 = TreeNode(9)
sub_node3 = TreeNode(3)
sub_node4 = TreeNode(2)
sub_node1.right, sub_node2.left, sub_node2.right = sub_node2, sub_node3, sub_node4
result5 = HasSubtree(node1, sub_node1)
```

【程序实现】：
```python
def HasSubtree(pRoot1, pRoot2):
    if not pRoot2:
        return False

    node_list = [pRoot1]
    while len(node_list) > 0:
        node = node_list.pop(0)
        if node.val == pRoot2.val:
            if is_root1_has_root2(node, pRoot2):
                return True
        if node.left:
            node_list.append(node.left)
        if node.right:
            node_list.append(node.right)
    return False


def is_root1_has_root2(node1, node2):
    if node2:
        if node1 is None:
            return False
        if node1.val == node2.val:
            result_left = is_root1_has_root2(node1.left, node2.left)
            result_right = is_root1_has_root2(node1.right, node2.right)
            return result_left and result_right
        else:
            return False
    else:
        return True
```
【说明】：

- 先层序遍历树 A，找出与树 B 根节点相同的节点；
- 从该节点开始，判断树 A 是否包含与树 B 相同的结构。
- 递归判断过程以树 B 为主：
    - 若树 B 节点存在，而树 A 节点不存在，则树 B 一定不是树 A 的子结构；
    - 若树 B 节点与树 A 节点不相同，则树 B 一定不是树 A 的子结构；
    - 若树 B 节点与树 A 节点相同，则继续递归遍历，直到叶结点。

【细节】：计算机内表示小数时存在误差，判断两个小数是否相等，比较好的方法是判断它们之差的绝对值在一个很小的范围内。如果相差很小，则可以认为它们是相等的。

【本题考点】：

- 考查应聘者对二叉树遍历算法的理解及递归编程能力；
- 考查应聘者所写代码的鲁棒性。

## 本章小结
本章从规范性、完整性和鲁棒性 3 个方面介绍了如何在面试时写出高质量的代码。

大多数面试都要求应聘者在白纸或者白板上些代码。应聘者在编码的时候要注意规范性，尽量清晰地书写每个字母，通过缩进和对齐括号让代码布局合理，同时合理命名代码中的变量和函数。

最好在编码之前全面考虑所有可能的输入，确保写出的代码在完成了**基本功能**之外，还考虑**边界条件**，并做好了**错误处理**。只有全面考虑到这 3 个方面的代码才是完整的代码。

另外，要确保自己写出的程序不会轻易崩溃。平时在写代码的时候，**应聘者最好养成防御性编程的习惯**，在函数入口判断输入是否有效，并对各种无效输入做好相应的处理。

【规范性】：

- 书写清晰
- 布局清晰
- 命名合理

【完整性】：

- 完成基本功能
- 考虑边界条件
- 做好错误处理

【鲁棒性】：

- 采取防御性编程
- 处理无效的输入