## 画图让抽象问题形象化
画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。很多面试题很抽象，不容易找到解决办法。这时不妨画出一些与题目相关的图形，借以辅助自己观察和思考。图形能使抽象的问题具体化、形象化，应聘者说不定通过几幅图形就能找到规律，从而找到问题的解决方案。

有不少与数据结构相关的问题，比如二叉树、二维数组、链表等问题，都可以采用画图的方法来分析。

在面试的时候，应聘者需要向面试官解释自己的思路。对于复杂的问题，应聘者光用语言未必能够说得清楚。这时候可以画出几幅图形，一边看着图形一边讲解，面试官就能更加轻松地理解应聘者的思路。这对应聘者是有益的，因为面试官会觉得他具有很好的沟通交流能力。

#### 面试题 27：二叉树的镜像
> 操作给定的二叉树，将其变换为源二叉树的镜像。

【数据结构】：
```python
class ListNode:

    def __init__(self, x):
        self.x = x
        self.left = None
        self.right = None
```

【测试用例】：

- 功能测试：正常的二叉树、只有左子树（右子树）的二叉树。
- 特殊输入测试：空树、只有根节点的树。

```python
# 特殊输入测试：空树
result1 = Mirror(None)

# 特殊输入测试：只有根节点的树
result2 = Mirror(ListNode(1))

# 功能测试：
node_1 = ListNode(8)
node_2 = ListNode(6)
node_3 = ListNode(10)
node_4 = ListNode(5)
node_5 = ListNode(7)
node_6 = ListNode(9)
node_7 = ListNode(11)
node_1.left, node_1.right = node_2, node_3
node_2.left, node_2.right = node_4, node_5
node_3.left, node_3.right = node_6, node_7
result3 = Mirror(node_1)

# 功能测试：只有左子树（右子树）的二叉树
node_1 = ListNode(1)
node_2 = ListNode(2)
node_3 = ListNode(3)
node_4 = ListNode(4)
node_1.left = node_2
node_2.left = node_3
node_3.left = node_4
result4 = Mirror(node_1)
```

【程序实现】：递归遍历。
```python
def Mirror(root):
    mirror_traver(root)
    return root


def mirror_traver(node):
    if node:
        Mirror(node.left)
        Mirror(node.right)
        node.left, node.right = node.right, node.left
```
【说明】：在遍历二叉树的同时交换当前节点的左右子节点。上述代码还有改进的空间，减少递归调用的深度。
```python
def mirror_traver(node):
    if node:
        if node.left:
            Mirror(node.left)
        if node.right:
            Mirror(node.right)
        node.left, node.right = node.right, node.left
```

【程序实现】：层序遍历。
```python
def Mirror(root):
    if not root:
        return None
    node_list = [root]

    while len(node_list) > 0:
        node = node_list.pop(0)
        if node.left:
            node_list.append(node.left)
        if node.right:
            node_list.append(node.right)
        node.left, node.right = node.right, node.left
    return root
```

【本题考点】：

- 考查应聘者对二叉树的理解。本题实质上是利用树的遍历算法解决问题。
- 考查应聘者的思维能力。树的镜像是一个抽象的概念，应聘者需要在短时间内想清楚求镜像的步骤并转换为代码。应聘者可以通过画图把抽象的问题形象化，这有助于其快速找到解题思路。

#### 面试题 28：对称的二叉树
> 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

【数据结构】：
```python
class ListNode:

    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

【测试用例】：

- 功能测试：对称的二叉树，非对称二叉树（结构不对称、结构对称但节点的值不对称），所有节点值都相同的二叉树。
- 特殊输入测试：空树，只有根节点的树。

```python
# 特殊输入测试：空树
result1 = isSymmetrical(None)

# 特殊输入测试：只有根节点的树
result2 = isSymmetrical(ListNode(1))

# 功能测试：非对称二叉树
node_1 = ListNode(8)
node_2 = ListNode(6)
node_3 = ListNode(10)
node_4 = ListNode(5)
node_5 = ListNode(7)
node_6 = ListNode(9)
node_7 = ListNode(11)
node_1.left, node_1.right = node_2, node_3
node_2.left, node_2.right = node_4, node_5
node_3.left, node_3.right = node_6, node_7
result3 = isSymmetrical(node_1)

# 功能测试：非对称二叉树
node_1 = ListNode(5)
node_2 = ListNode(3)
node_3 = ListNode(3)
node_4 = ListNode(4)
node_5 = ListNode(4)
node_6 = ListNode(2)
node_7 = ListNode(2)
node_8 = ListNode(1)
node_1.left, node_1.right = node_2, node_3
node_2.left = node_4
node_3.right = node_5
node_4.left = node_6
node_5.right = node_7
node_7.right = node_8
result4 = isSymmetrical(node_1)

# 功能测试：非对称二叉树
node_1 = ListNode(5)
node_2 = ListNode(5)
node_3 = ListNode(5)
node_4 = ListNode(5)
node_5 = ListNode(5)
node_6 = ListNode(5)
node_7 = ListNode(5)
node_1.left, node_1.right = node_2, node_3
node_2.left = node_4
node_3.right = node_5
node_4.left = node_6
node_5.left = node_7
result5 = isSymmetrical(node_1)

# 功能测试：对称二叉树
node_1 = ListNode(8)
node_2 = ListNode(6)
node_3 = ListNode(6)
node_4 = ListNode(5)
node_5 = ListNode(7)
node_6 = ListNode(7)
node_7 = ListNode(5)
node_1.left, node_1.right = node_2, node_3
node_2.left, node_2.right = node_4, node_5
node_3.left, node_3.right = node_6, node_7
result6 = isSymmetrical(node_1)
```

【注意事项】：空树和只有根节点的树都被视为对称的二叉树。

【程序实现】：层序遍历实现。
```python
def isSymmetrical(pRoot):
    if not pRoot:
        return True
    node_list = [pRoot]

    while len(node_list):
        layer_nodes = []
        for node in node_list:
            if node:
                layer_nodes.append(node.left)
                layer_nodes.append(node.right)
        # 判断是否关于中点对称
        length = len(layer_nodes)
        start, end = 0, length - 1
        if length & 0x01 == 1:
            return False
        while True:
            if start >= end:
                break
            node_start = layer_nodes[start].val if layer_nodes[start] else 0
            node_end = layer_nodes[end].val if layer_nodes[end] else 0
            if node_start != node_end:
                return False
            start += 1
            end -= 1
        node_list = layer_nodes
    return True
```
【说明】：

- 首先针对特殊输入进行相应的处理。
- 层序遍历过程中获取子节点集合，并保存到列表 layer_nodes 中。
- 判断 layer_nodes 中的元素个数是否为偶数，若为奇数，则说明不对称，可直接返回 False。
- 若为偶数，则继续判断：从列表的两端逐步向中间靠拢，并依次比较列表两端的节点是否相同。若不相同，则说明不对称，返回 False。
- 循环结束完毕，说明当前二叉树是对称的，返回 True。
- 难点：layer_nodes 需要记录节点的位置，单纯存储值无法正确判断，例如测试用例 5（result5）。

【程序实现】：先序遍历和后序遍历。
```python
def isSymmetrical(pRoot):
    if not pRoot:
        return True
    pre_nodes = []
    past_nodes = []

    def pre_traver(node):
        if node:
            pre_nodes.append(node.val)
            pre_traver(node.left)
            pre_traver(node.right)
        else:
            pre_nodes.append('#')

    def past_traver(node):
        if node:
            past_traver(node.left)
            past_traver(node.right)
            past_nodes.append(node.val)
        else:
            past_nodes.append('#')

    pre_traver(pRoot)
    past_traver(pRoot)
    print(pre_nodes, list(reversed(past_nodes)))
    return pre_nodes == list(reversed(past_nodes))
```
【说明】：先序遍历和后序遍历的节点顺序恰好是相反的，因此我们可以分别通过先序遍历和后序遍历得到遍历顺序，然后将其中一个顺序倒置，最后进行比较。需要注意的是，空节点也需要保存，目的同上一个程序实现（记录位置信息）。具体可参考书本上的讲解 P 160。

【改进】：将后序遍历修改下，可减少后续的倒置操作。
```python
    def past_traver(node):
        if node:
            past_nodes.append(node.val)
            past_traver(node.right)
            past_traver(node.left)
        else:
            past_nodes.append('#')

    pre_traver(pRoot)
    past_traver(pRoot)
    print(pre_nodes, past_nodes)
    return pre_nodes == past_nodes
```

【本题考点】：

- 考查应聘者对二叉树的理解。本题实质上利用树的遍历算法解决问题。
- 考查应聘者的思维能力。树的对称是一个抽象的概念，应聘者需要在短时间内想清楚判断对称的步骤并转换为代码。应聘者可以通过画图把抽象的问题形象化，这有助于其快速找到解题思路。

## 举例让抽象问题具体化
借助举例模拟的方法来思考分析复杂的问题。当一眼看不出问题中隐藏的规律的时候，可以试着用一两个具体的例子模拟操作的过程，这样说不定就能通过具体的例子找到抽象的规律。

具体的例子也可以帮助我们向面试官解释算法思路。算法通常是很抽象的，用语言不容易表述得清楚，可以考虑举一两个具体的例子，告诉面试官我们的算法是怎么一步步处理这个例子的。

具体的例子还能帮助我们确保代码的质量。在面试中写完代码之后，应该先检查一遍，确保没有问题再交给面试官。怎么检查呢？可以运行几个测试用例。在分析问题的时候采用的例子就是测试用例。可以把这些例子当作测试用例，在心里模拟运行，看每一步操作之后的结果和我们预期的是不是一致。如果每一步的结果都和事先预计的一致，我们就能确保代码的正确性了。

#### 面试题 30：包含 min 函数的栈
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为O(1)）。

【数据结构】：
```python
class Solution:
    def push(self, node):
        # write code here
    def pop(self):
        # write code here
    def top(self):
        # write code here
    def min(self):
        # write code here
```

【测试用例】：

- 新压入栈的数字比之前的最小值大；
- 新压入栈的数字比之前的最小值小；
- 弹出栈的数字不是最小元素；
- 弹出栈的数字是最小元素。

【程序实现】：添加变量保存最小元素
```python
class Solution:
    stack = []
    min_param = []

    def push(self, node):
        if len(self.min_param) == 0:
            self.min_param.append(node)
        else:
            if self.min_param[0] > node:
                self.min_param[0] = node
        self.stack.append(node)

    def pop(self):
        if len(self.stack) == 0:
            return
        node = self.stack.pop()
        if node == self.min_param[0]:
            self.min_param[0] = min(self.stack)
        return node

    def top(self):
        if len(self.stack) != 0:
            print(self.stack[-1])

    def min(self):
        if len(self.min_param) == 1:
            return self.min_param[0]
```
【说明】：

- push：比较当前添加的元素是否比最小值小，若比最小值小，则更新最小值。
- pop：若当前 pop 的值为最小值，则重新寻找最小值。

【程序实现】：辅助栈
```python
class Solution:
    stack = []
    stack_min = []

    def push(self, node):
        if len(self.stack_min) == 0:
            self.stack_min.append(node)
        else:
            if self.stack_min[-1] < node:
                self.stack_min.append(self.stack_min[-1])
            else:
                self.stack_min.append(node)
        self.stack.append(node)

    def pop(self):
        if len(self.stack) == 0:
            return
        node = self.stack.pop()
        self.stack_min.pop()
        return node

    def top(self):
        if len(self.stack) != 0:
            print(self.stack[-1])

    def min(self):
        if len(self.stack_min) > 0:
            return self.stack_min[-1]
```
【说明】：具体可参考《剑指offer》P166-P167。

【本题考点】：

- 考查应聘者分析复杂问题的能力。
- 考查应聘者对栈的理解。

#### 面试题 31：栈的压入、弹出序列
> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。

【测试用例】：

- 功能测试：正确的弹出序列、错误的弹出序列。
- 特殊输入测试：两个空序列。

【程序实现】：中规中矩的实现。
```python
def IsPopOrder(pushV, popV):
    length = len(pushV)
    if length == 0:
        return False
    stack = []
    i_push, i_pop = 0, 0

    # 入栈循环
    while i_push < length:
        if pushV[i_push] != popV[i_pop]:
            if len(stack) > 0 and stack[-1] == popV[i_pop]:
                stack.pop()
                i_pop += 1
            else:
                stack.append(pushV[i_push])
                i_push += 1
        else:
            i_pop += 1
            i_push += 1

    # 出栈循环
    while len(stack) > 0:
        if stack.pop() != popV[i_pop]:
            return False
        i_pop += 1
    return True


if __name__ == '__main__':
    push_v = [1, 2, 3, 4, 5]
    pop_v1 = [4, 5, 3, 2, 1]
    pop_v2 = [4, 3, 5, 1, 2]
    print(IsPopOrder(push_v, pop_v1))
    print(IsPopOrder(push_v, pop_v2))
    print(IsPopOrder([], [])
    
# 输出
True
False
False
```
【说明】：
- 压栈操作：在压栈过程中，若当前压入栈的元素与出栈序列的第一个元素相等，则表明当前元素入栈后立即出栈，因此当前元素不需要压入栈，入栈和出栈序列向后移一位。若不相等，则判断辅助栈最后一个元素是否与出栈序列的第一个元素相等。若相等，则出栈，出栈序列后移一位。若不相等，则入栈序列后移一位，即继续入栈。
- 出栈操作：在出栈过程中，只需要 pop 辅助栈，比较每一次 pop 的元素是否和出栈序列相等。若不相等，则 return False。循环结束，返回 True。

【程序实现】：书本方法。
```python
def IsPopOrder(pushV, popV):
    length = len(pushV)
    if length == 0:
        return False
    stack = []
    i_push, i_pop = 0, 0

    # 入栈循环
    while i_push < length:
        stack.append(pushV[i_push])
        i_push += 1
        # 判断栈顶元素是否与出栈序列的第一个元素相等
        while True:
            if len(stack) > 0 and stack[-1] == popV[i_pop]:
                stack.pop()
                i_pop += 1
            else:
                break
    return i_push == i_pop
```
【说明】：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。

【本题考点】：

- 考查应聘者分析复杂问题的能力。
- 考查应聘者对栈的理解。

#### 面试题 32：从上到下打印二叉树
> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。

【注意】：虽然题目中说的是打印，但实际上是要将节点的值存放到列表中返回。其实也很好理解，在线编程不可能判定 print 打印的内容，而是判定返回列表的内容来得轻松。

【数据结构】：
```python
class ListNode:

    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

【测试用例】：

- 功能测试：正常的二叉树，只有左子树（右子树）的二叉树。
- 特殊输入测试：空树，只有根节点的二叉树。

```python
# 特殊输入处理：空树
PrintFromTopToBottom(None)

# 特殊输入处理：只有根节点的二叉树
PrintFromTopToBottom(ListNode(1))

# 功能测试：正常二叉树
node_1 = ListNode(8)
node_2 = ListNode(6)
node_3 = ListNode(10)
node_4 = ListNode(5)
node_5 = ListNode(7)
node_6 = ListNode(9)
node_7 = ListNode(11)
node_1.left, node_1.right = node_2, node_3
node_2.left, node_2.right = node_4, node_5
node_3.left, node_3.right = node_6, node_7
PrintFromTopToBottom(node_1)

# 功能测试：只有左子树（右子树）的二叉树
node_1 = ListNode(1)
node_2 = ListNode(2)
node_3 = ListNode(3)
node_4 = ListNode(4)
node_5 = ListNode(5)
node_1.left, node_2.left, node_3.left, node_4.left = node_2, node_3, node_4, node_5
PrintFromTopToBottom(node_1)
```

【程序实现】：层序遍历。
```python
def PrintFromTopToBottom(root):
    if not root:
        return []

    node_list = [root]
    result = []
    while len(node_list):
        node = node_list.pop(0)
        result.append(node.val)
        if node.left:
            node_list.append(node.left)
        if node.right:
            node_list.append(node.right)
    return result
```
【说明】：利用树的层序遍历方式即可满足题目要求。上述代码还可以进行优化，使用 deque 来替代列表。
```python
node_list = deque()
node_list.append(root)
result = []
while len(node_list):
    node = node_list.popleft()
    result.append(node.val)
    if node.left:
        node_list.append(node.left)
    if node.right:
        node_list.append(node.right)
```

【效率】：

- 时间效率：O(n)。
- 空间效率：O(n)，实际上空间效率要小于 O(n)，等于 2 的树深度次方。

【本题考点】：

- 考查应聘者的思维能力。
- 考查应聘者对二叉树及队列的理解。

#### 面试题 32-2：分行从上到下打印二叉树
> 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

【测试用例】：同面试题 33。

【程序实现】：
```python
def PrintFromTopToBottom(root):
    if not root:
        return []

    node_list = deque()
    node_list.append(root)
    count = 1
    while count > 0:
        layer_nodes = []
        next_count = 0
        for i in range(count):
            node = node_list.popleft()
            layer_nodes.append(node.val)
            if node.left:
                node_list.append(node.left)
                next_count += 1
            if node.right:
                node_list.append(node.right)
                next_count += 1
        count = next_count
        print(str(layer_nodes))
```
【说明】：为了把二叉树的每一行单独打印到一行里，需要借助两个变量。

- 节点数：表示在当前层中还没有打印的节点数。
- 下层节点数：表示下一层节点的数目。

【牛客网代码】：
```python
if not pRoot:
    return []

node_list = []
node_list.append(pRoot)
count = 1
total_list = []
while count > 0:
    layer_nodes = []
    next_count = 0
    for i in range(count):
        node = node_list.pop(0)
        layer_nodes.append(node.val)
        if node.left:
            node_list.append(node.left)
            next_count += 1
        if node.right:
            node_list.append(node.right)
            next_count += 1
    count = next_count
    total_list.append(layer_nodes)
return total_list
```

#### 面试题 32-3：之字形打印二叉树
> 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，其他行以此类推。

【测试用例】：同面试题 33。

【程序实现】：数组逆序方法。
```python
def PrintFromTopToBottom(root):
    if not root:
        return []

    node_list = deque()
    node_list.append(root)
    count = 1
    layer = 0
    while count > 0:
        layer_nodes = []
        next_count = 0
        for i in range(count):
            node = node_list.popleft()
            layer_nodes.append(node.val)
            if node.left:
                node_list.append(node.left)
                next_count += 1
            if node.right:
                node_list.append(node.right)
                next_count += 1
        count = next_count
        layer += 1
        if layer & 0x01 == 0:
            layer_nodes.sort(reverse=True)
        print(str(layer_nodes))
```
【说明】：在面试题 33-2 的基础上新增一个变量 layer 用以判断当前层数。若为奇数，则从左到右打印，即顺序打印。若为偶数，则从右到左打印，即逆序打印。当然我们也可以自行实现数组的逆序输出。

【程序实现】：堆栈实现。
```python
    if not root:
        return []

    node_list = [root]
    next_list = []
    count = 1
    layer = 1
    while count > 0:
        layer_nodes = []
        next_count = 0
        for i in range(count):
            node = node_list.pop()
            layer_nodes.append(node.val)
            if layer & 0x01 != 0:
                if node.left:
                    next_list.append(node.left)
                    next_count += 1
                if node.right:
                    next_list.append(node.right)
                    next_count += 1
            else:
                if node.right:
                    next_list.append(node.right)
                    next_count += 1
                if node.left:
                    next_list.append(node.left)
                    next_count += 1
        node_list = next_list.copy()
        count = next_count
        layer += 1
        print(str(layer_nodes))
```
【说明】：需要两个栈，在打印某一层的节点时，把下一层的子节点保存到相应的栈里。如果当前打印的是奇数层，则先保存左子节点再保存右子节点；如果当前打印的是偶数层，则先保存右子节点再保存左子节点。

#### 面试题 33：二叉搜索树的后序遍历序列
> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两个数字都互不相同。

【测试用例】：

- 功能测试：正确的二叉搜索树后序遍历数组，错误的二叉搜索树后序遍历数组。
- 特殊输入测试：空数组，只有一个值的数组。

```python
# 特殊输入测试：空数组
result1 = VerifySquenceOfBST([])

# 特殊输入测试：只有一个值的数组
result2 = VerifySquenceOfBST([1])

# 功能测试：成功
result3 = VerifySquenceOfBST([5, 7, 6, 9, 11, 10, 8])

# 功能测试：失败
result4 = VerifySquenceOfBST([7, 4, 6, 5])

# 功能测试：成功
result5 = VerifySquenceOfBST([1, 4, 23, 37, 29, 41, 12, 84, 71, 100, 90, 60])
```

【程序实现】：递归实现。
```python
def VerifySquenceOfBST(sequence):
    if len(sequence) == 0:
        return False
    return loop(sequence)


def loop(sequence):
    length = len(sequence)
    if length <= 1:
        return True
    root = sequence[-1]
    middle = 0
    is_big = False
    for i in range(length):
        if sequence[i] >= root:
            is_big = True
            middle = i
        if sequence[i] < root and is_big:
            return False
    return loop(sequence[:middle]) & loop(sequence[middle:length - 1])
```
【说明】：

- 首先对输入进行验证，判断是否为空数组。若为空数组，则直接返回 False。
- 在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树节点的值，它们都比根结点的值小；第二部分是右子树节点的值，它们都比根结点的值大。因此，若是不能将数组划分为两部分，换言之，前半部分存在比根结点的值大的数，则说明当前后序遍历数组没有对应的二叉搜索树，此时可直接返回 Fasle。
- 不断递归，直到抵达叶节点。
- 具体内容可阅读《剑指offer》P180。

【改进】：
```python
def VerifySquenceOfBST(sequence):
    length = len(sequence)
    if length == 0:
        return False
    root = sequence[-1]
    middle = 0
    for i in range(length - 1):
        if sequence[i] > root:
            break
        middle += 1
    for i in range(middle + 1, length - 1):
        if sequence[i] < root:
            return False
    result_left, result_right = True, True
    if middle > 0:
        result_left = VerifySquenceOfBST(sequence[:middle])
    if middle < length - 1:
        result_right = VerifySquenceOfBST(sequence[middle:length-1])
    return result_left & result_right
```
【效率】：

- 时间效率：O(nlogn)，n 用以检索数组是否划分为两部分，logn 为递归层级。
- 空间效率：O(logn)。

【本题考点】：

- 考查应聘者分析复杂问题的思维能力。能否解决这道题的关键在于应聘者是否能找出后序遍历的规律。一旦找到了规律，用递归的代码编码相对而言就简单了。
- 考查应聘者对二叉树后序遍历的理解。

#### 面试题 34：二叉树中和为某一值的路径
> 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

【数据结构】：
```python
class ListNode:

    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

【测试用例】：

- 功能测试：二叉树中有一条、多条符合要求的路径，二叉树中没有符合要求的路径。
- 特殊输入测试：空树，值为负数或 0。

```python
# 特殊输入测试：expectNumber 小于等于 0
result1 = FindPath(ListNode(1), 0)
result2 = FindPath(ListNode(1), -1)

# 特殊输入测试：空树
result3 = FindPath(None, 10)

# 功能测试：符合要求
node_1 = ListNode(10)
node_2 = ListNode(5)
node_3 = ListNode(12)
node_4 = ListNode(4)
node_5 = ListNode(7)
node_1.left, node_1.right = node_2, node_3
node_2.left, node_2.right = node_4, node_5
result4 = FindPath(node_1, 22)

# 功能测试：不符合要求
result5 = FindPath(node_1, 20)

# 功能测试：不符合要求
result6 = FindPath(node_1, 15)

# 功能测试：符合要求
result7 = FindPath(node_1, 19)
```

【程序实现】：先序遍历。
```python
def FindPath(root, expectNumber):
    if expectNumber <= 0 or root is None:
        return []
    path = []
    pre_traver(root, expectNumber, 0, [], path)
    return path


def pre_traver(node, number, value, path, total_path):
    path_new = []
    path_new.extend(path)
    path_new.append(node.val)
    value += node.val
    if not node.left and not node.right and value == number:
        total_path.append(path_new)
    else:
        if node.left:
            pre_traver(node.left, number, value, path_new, total_path)
        if node.right:
            pre_traver(node.right, number, value, path_new, total_path)
```
【说明】：

- 每一步遍历时，将当前节点添加到路径中，同时计算当前路径累加的值（需要注意 Python 语言的特性）。

```python
path_new = []
path_new.extend(path)
path_new.append(node.val)
value += node.val
```
- 判断当前节点是否为叶节点。若为叶节点且累加的值符合要求，则将当前路径添加到总路径中。

```python
if not node.left and not node.right and value == number:
    total_path.append(path_new)
```
- 否则，继续遍历。

```python
if node.left:
    pre_traver(node.left, number, value, path_new, total_path)
if node.right:
    pre_traver(node.right, number, value, path_new, total_path)
```
【其他】：如果仅仅是打印而非获取所有路径则会相对简单一些。
```python
def FindPath(root, expectNumber):
    if expectNumber <= 0 or root is None:
        return []
    path = []
    pre_traver(root, expectNumber, 0, [])
    return path


def pre_traver(node, number, value, path):
    path.append(node.val)
    value += node.val
    if not node.left and not node.right and value == number:
        print(str(path))
    else:
        if node.left:
            pre_traver(node.left, number, value, path)
        if node.right:
            pre_traver(node.right, number, value, path)
    path.pop()
```

【本题考点】：

- 考查应聘者分析复杂问题的思维能力。
- 考查应聘者对二叉树的前序遍历的理解。

## 分解让复杂问题简单化
在面试中，当我们遇到复杂的大问题的时候，如果能够先把大问题分解成若干个简单的小问题，然后再逐个解决这些小问题，则可能也会容易很多。

我们可以按照解决问题的步骤来分解复杂问题，每一步解决一个小问题。比如在面试题 35“复杂链表的复制”中，将复杂链表复制的过程分解成 3 个步骤。在写代码的时候为每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。

在计算机领域有一类算法叫分治法，即“分而治之”，采用的就是各个击破的思想。我们把分解之后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。

#### 面试题 35：复杂链表的复制
> 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。

【难点】：如何处理 random 指向的节点复制。

【数据结构】：
```python
class RandomListNode:

    def __init__(self, x):
        self.label = x
        self.next = None
        self.random = None
```

【测试用例】：

- 特殊输入测试：空链表；
- 功能测试：单节点链表，节点的 random 指向节点自身，两个节点 random 形成环状结构。

【程序实现】：哈希表
```python
def Clone(pHead):
    if not pHead:
        return None

    node = pHead
    node_list = []
    node_clone_list = []
    node_hash = {}
    
    # 创建复制链表节点，并构造哈希表
    while node:
        node_list.append(node)
        node_clone = RandomListNode(node.label)
        node_clone_list.append(node_clone)
        node_hash[node] = node_clone
        node = node.next
    
    # 链接复制链表节点的同时，链接 random
    for i in range(len(node_clone_list) - 1):
        node = node_list[i]
        if node.random:
            node_clone_list[i].random = node_hash[node.random]
        node_clone_list[i].next = node_clone_list[i + 1]
    return node_clone_list[0]
```
【说明】：

- 第一步创建复制链表节点，并构造哈希表；
- 链接复制链表节点的同时，链接节点的 random。
- 这种方法相当于用空间换时间。

【效率】：

- 时间效率：O(n)，创建复制链表节点 O(n)，链接过程 O(n)。
- 空间效率：O(n)，哈希表的长度。

【程序实现】：巧妙的方法
```python
def Clone(pHead):
    if not pHead:
        return None

    node = pHead
    while node:
        node_clone = RandomListNode(node.label)
        node_clone.next, node.next = node.next, node_clone
        node = node_clone.next

    node = pHead
    while node:
        if node.random:
            node_random = node.random
            node.next.random = node_random.next
        node = node.next.next

    node, count, clone_head = pHead, 0, pHead.next
    while node.next:
        temp = node.next
        node.next = node.next.next
        node = temp
    return clone_head
```
【说明】：

- 第一步，根据原始链表的每个节点 N 创建对应的 N'，并把 N' 链接在 N 的后面；
- 第二步，设置复制节点的 random。假设原始链表上的 N 的 random 指向节点 S，那么其对应复制出来的 N' 是 N 的 next 指向的节点，同样 S' 是 S 的 next 指向的节点。所以可以通过 node.next.random = node.random.next 来实现链接。
- 第三步，把这个长链拆分成两个链表，把奇数位置的节点用 next 链接起来就是原始链表，把偶数位置的节点用 next 链接起来就是复制出来的链表。

【效率】：

- 时间效率：三步都为 O(n)，所以总时长为 O(n)；
- 空间效率：O(1)，没有使用额外的内存空间。

【本题考点】：

- 考查应聘者对复杂问题的思维能力。
- 考查应聘者分析时间效率和空间效率的能力。

#### 面试题 36：二叉搜索树与双向链表
> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

【数据结构】：
```python
class TreeNode:

    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

【测试用例】：

- 特殊输入测试：空树、只有根节点的树；
- 功能测试：完全的二叉搜索树，只有左子树（右子树）的二叉搜索树。

```python
# 特殊输入测试：空树
result1 = Convert(None)

# 特殊输入测试：只有根节点的树
result2 = Convert(TreeNode(1))

# 功能测试：完全二叉搜索树
node1 = TreeNode(5)
node2 = TreeNode(3)
node3 = TreeNode(7)
node4 = TreeNode(2)
node5 = TreeNode(4)
node6 = TreeNode(6)
node7 = TreeNode(8)
node1.left, node1.right = node2, node3
node2.left, node2.right = node4, node5
node3.left, node3.right = node6, node7
result3 = Convert(node1)

# 功能测试：只有左子树的二叉搜索树
node1 = TreeNode(5)
node2 = TreeNode(4)
node3 = TreeNode(3)
node4 = TreeNode(2)
node5 = TreeNode(1)
node1.left, node2.left = node2, node3
node3.left, node4.left = node4, node5
result4 = Convert(node1)
```

【程序实现】：
```python
def Convert(pRootOfTree):
    if not pRootOfTree:
        return None
    path = []
    in_order_traver(pRootOfTree, path)
    for i in range(len(path)):
        if i - 1 < 0:
            path[i].left = None
        else:
            path[i].left = path[i - 1]
        if i + 1 > len(path) - 1:
            path[i].right = None
        else:
            path[i].right = path[i + 1]
    return path[0]


def in_order_traver(node, path):
    if node.left:
        in_order_traver(node.left, path)
    path.append(node)
    if node.right:
        in_order_traver(node.right, path)
```
【说明】：因为需要排序后的双向链表，因此先通过中序遍历二叉搜索树，以获得排序的遍历序列并存放到 path 列表中。然后调整 path 列表中每一项的指针，使当前位置的节点 left 指向前一个位置的节点，right 指向后一个节点的位置。需要注意边界点的 left 和 right 处理。

【效率】：

- 时间效率：遍历二叉搜索树需要 O(n)，处理 path 列表也需要 O(n) 时间，总时间为 O(n)；
- 空间效率：O(n)，创建 path 列表所需的内存空间。

【程序实现】：在递归的过程中完成指针调整
```
def Convert(pRootOfTree):
    if not pRootOfTree:
        return None

    in_order_traver(pRootOfTree, [None])
    root = pRootOfTree
    while root.left:
        root = root.left
    return root


def in_order_traver(node, last_node):
    if node.left:
        in_order_traver(node.left, last_node)
    if last_node[0]:
        last_node[0].right = node
    node.left = last_node[0]
    last_node[0] = node
    if node.right:
        in_order_traver(node.right, last_node)
```
【说明】：关键在于每次递归的过程中记录上一个节点。具体内容可参考《剑指offer》P192-P194。

【本题考点】：

- 考查应聘者分析复杂问题的能力。
- 考查应聘者对二叉树和双向链表的理解及编程能力。

#### 面试题 37：序列化二叉树
> 请实现两个函数，分别用来序列化和反序列化二叉树。

【数据结构】：
```python
class TreeNode:
    
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

【测试用例】：

- 特殊输入测试：空树，只有根节点的树；
- 功能测试：完全二叉树，只有左子树/右子树的二叉树，所有节点的值都相同的二叉树。

【程序实现】：
```python
class Solution:

    def __init__(self):
        self.root = None

    def Serialize(self, root):
        path = []
        self.pre_order(root, path)
        return ",".join(path)

    def Deserialize(self, s):
        node_list = s.split(',')
        root = self.pre_order_create(node_list)
        self.root = root

    def pre_order(self, node, path):
        if node:
            path.append(str(node.val))
            self.pre_order(node.left, path)
            self.pre_order(node.right, path)
        else:
            path.append('#')

    def pre_order_create(self, node_list):
        node_val = node_list.pop(0)
        if node_val == '#':
            return None
        node = TreeNode(int(node_val))
        node.left = self.pre_order_create(node_list)
        node.right = self.pre_order_create(node_list)
        return node
```
【说明】：实际上就是先序遍历以及根据先序遍历创建二叉树。

【本题考点】：

- 考查应聘者分析复杂问题的能力。
- 考查应聘者对二叉树遍历的理解及编程能力。

#### 面试题 38：字符串的排列
> 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

【测试用例】：

- 特殊输入测试：空字符串，单个字符串；
- 功能测试：符合要求的字符串，存在重复的字符串。

```python
# 特殊输入测试：空字符串
result1 = Permutation('')

# 特殊输入测试：单个字符串
result2 = Permutation('a')

# 功能测试：符合要求
result3 = Permutation('abc')

# 功能测试：重复字符串
result4 = Permutation('abbc')
```

【程序实现】：
```python
def Permutation(ss):
    if len(ss) == 0:
        return []
    ss_list = list(ss)
    total_str = []
    loop(ss_list, '', total_str)
    return sorted(list(set(total_str)))


def loop(str_list, string, total_str):
    if len(str_list) == 0:
        total_str.append(string)
    for i in range(len(str_list)):
        loop(str_list[0:i] + str_list[i + 1:], string + str_list[i], total_str)
```

【本题考点】：

- 考查应聘者的思维能力。
- 考查应聘者对递归的理解和编程能力。

## 本章小结
在面试时，我们难免会遇到难题，画图、举例和分解这三种方法能够帮助我们解决复杂的问题。

图形能使抽象的问题形象化。当面试题涉及链表、二叉树等数据结构时，如果在纸上画几张草图，则题目中隐藏的规律就有可能变得很直观。

一两个例子能使抽象的问题具体化。很多与算法相关的问题都很抽象，未必一眼就能看出它们的规律。这时候我们不妨举几个例子，一步一步模拟运行的过程，说不定能发现其中的规律，从而找到解决问题的窍门。

把复杂问题分解成若干个小问题，是解决很多复杂问题的有效方法。如果我们遇到的问题很大，则可以尝试先把大问题分解成小问题，然后再递归地解决这些小问题。分治法、动态规划等方法应用的都是分解复杂问题的思路。